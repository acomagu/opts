package main

import (
	"io/ioutil"
	"strings"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/pkg/errors"
)

func TestGenerate(t *testing.T) {
	tests := map[string]struct {
		imports  []string
		pkgName  string
		typeName string
		optName  string
		append   bool
		before   string
		after    string
	}{
		"empty": {
			pkgName:  "main",
			typeName: "Auth",
			optName:  "Auth",
			append:   false,
			before:   "",
			after: `// Code generated by opts. DO NOT EDIT.

package main

type Opt interface {
	set(interface{})
}

// Auth
type authSetter interface {
	setAuth(Auth)
}

type authParam struct {
	withAuth bool
	auth     Auth
}

func (p *authParam) setAuth(v Auth) {
	p.withAuth = true
	p.auth = v
}

type authOpt struct {
	v Auth
}

func Auth(v Auth) *authOpt {
	return &authOpt{
		v: v,
	}
}

func (o *authOpt) set(p interface{}) {
	p.(authSetter).setAuth(o.v)
}
`,
		},
		"append": {
			append:   true,
			pkgName:  "main",
			typeName: "*Byte",
			optName:  "Byte",
			before: `// Code generated by opts. DO NOT EDIT.

package main

type Opt interface {
	set(interface{})
}

// Auth
type authSetter interface {
	setAuth(Auth)
}

type authParam struct {
	withAuth bool
	auth     Auth
}

func (p *authParam) setAuth(v Auth) {
	p.withAuth = true
	p.auth = v
}

type authOpt struct {
	v Auth
}

func Auth(v Auth) *authOpt {
	return &authOpt{
		v: v,
	}
}

func (o *authOpt) set(p interface{}) {
	p.(authSetter).setAuth(o.v)
}
`,
			after: `// Code generated by opts. DO NOT EDIT.

package main

type Opt interface {
	set(interface{})
}

// Auth
type authSetter interface {
	setAuth(Auth)
}

type authParam struct {
	withAuth bool
	auth     Auth
}

func (p *authParam) setAuth(v Auth) {
	p.withAuth = true
	p.auth = v
}

type authOpt struct {
	v Auth
}

func Auth(v Auth) *authOpt {
	return &authOpt{
		v: v,
	}
}

func (o *authOpt) set(p interface{}) {
	p.(authSetter).setAuth(o.v)
}

// Byte
type byteSetter interface {
	setByte(*Byte)
}

type byteParam struct {
	withByte bool
	byte     *Byte
}

func (p *byteParam) setByte(v *Byte) {
	p.withByte = true
	p.byte = v
}

type byteOpt struct {
	v *Byte
}

func Byte(v *Byte) *byteOpt {
	return &byteOpt{
		v: v,
	}
}

func (o *byteOpt) set(p interface{}) {
	p.(byteSetter).setByte(o.v)
}
`,
		},
		"optName": {
			append:   false,
			pkgName:  "main",
			typeName: "*int",
			optName:  "Count",
			before:   "",
			after: `// Code generated by opts. DO NOT EDIT.

package main

type Opt interface {
	set(interface{})
}

// Count
type countSetter interface {
	setCount(*int)
}

type countParam struct {
	withCount bool
	count     *int
}

func (p *countParam) setCount(v *int) {
	p.withCount = true
	p.count = v
}

type countOpt struct {
	v *int
}

func Count(v *int) *countOpt {
	return &countOpt{
		v: v,
	}
}

func (o *countOpt) set(p interface{}) {
	p.(countSetter).setCount(o.v)
}
`,
		},
		"override": {
			pkgName:  "main",
			typeName: "*int",
			optName:  "Count",
			append:   false,
			before: `// Code generated by opts. DO NOT EDIT.

package main

type Opt interface {
	set(interface{})
}

// Auth
type authSetter interface {
	setAuth(Auth)
}

type authParam struct {
	withAuth bool
	auth     Auth
}

func (p *authParam) setAuth(v Auth) {
	p.withAuth = true
	p.auth = v
}

type authOpt struct {
	v Auth
}

func Auth(v Auth) *authOpt {
	return &authOpt{
		v: v,
	}
}

func (o *authOpt) set(p interface{}) {
	p.(authSetter).setAuth(o.v)
}

// Byte
type byteSetter interface {
	setByte(*Byte)
}

type byteParam struct {
	withByte bool
	byte     *Byte
}

func (p *byteParam) setByte(v *Byte) {
	p.withByte = true
	p.byte = v
}

type byteOpt struct {
	v *Byte
}

func Byte(v *Byte) *byteOpt {
	return &byteOpt{
		v: v,
	}
}

func (o *byteOpt) set(p interface{}) {
	p.(byteSetter).setByte(o.v)
}
`,
			after: `// Code generated by opts. DO NOT EDIT.

package main

type Opt interface {
	set(interface{})
}

// Count
type countSetter interface {
	setCount(*int)
}

type countParam struct {
	withCount bool
	count     *int
}

func (p *countParam) setCount(v *int) {
	p.withCount = true
	p.count = v
}

type countOpt struct {
	v *int
}

func Count(v *int) *countOpt {
	return &countOpt{
		v: v,
	}
}

func (o *countOpt) set(p interface{}) {
	p.(countSetter).setCount(o.v)
}
`,
		},
		"import": {
			append:   true,
			pkgName:  "main",
			imports:  []string{"os"},
			typeName: "*os.File",
			optName:  "File",
			before: `// Code generated by opts. DO NOT EDIT.

package main

import "io"

type Opt interface {
	set(interface{})
}

// Reader
type readerSetter interface {
	setReader(io.Reader)
}

type readerParam struct {
	withReader bool
	reader     io.Reader
}

func (p *readerParam) setReader(v io.Reader) {
	p.withReader = true
	p.reader = v
}

type readerOpt struct {
	v io.Reader
}

func Reader(v io.Reader) *readerOpt {
	return &readerOpt{
		v: v,
	}
}

func (o *readerOpt) set(p interface{}) {
	p.(readerSetter).setReader(o.v)
}
`,
			after: `// Code generated by opts. DO NOT EDIT.

package main

import "os"

import "io"

type Opt interface {
	set(interface{})
}

// Reader
type readerSetter interface {
	setReader(io.Reader)
}

type readerParam struct {
	withReader bool
	reader     io.Reader
}

func (p *readerParam) setReader(v io.Reader) {
	p.withReader = true
	p.reader = v
}

type readerOpt struct {
	v io.Reader
}

func Reader(v io.Reader) *readerOpt {
	return &readerOpt{
		v: v,
	}
}

func (o *readerOpt) set(p interface{}) {
	p.(readerSetter).setReader(o.v)
}

// File
type fileSetter interface {
	setFile(*os.File)
}

type fileParam struct {
	withFile bool
	file     *os.File
}

func (p *fileParam) setFile(v *os.File) {
	p.withFile = true
	p.file = v
}

type fileOpt struct {
	v *os.File
}

func File(v *os.File) *fileOpt {
	return &fileOpt{
		v: v,
	}
}

func (o *fileOpt) set(p interface{}) {
	p.(fileSetter).setFile(o.v)
}
`,
		},
	}

	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			f, err := ioutil.TempFile("", "opt.go")
			if err != nil {
				t.Fatal(errors.Wrap(err, "could not create temp file"))
			}

			if _, err := f.WriteString(test.before); err != nil {
				t.Fatal(errors.Wrap(err, "could not write to temp file"))
			}

			f.Seek(0, 0)

			g := &Generator{
				f:       f,
				append:  test.append,
				imports: test.imports,
				pkgName: test.pkgName,
				typName: test.typeName,
				optName: test.optName,
			}
			if err := g.generate(); err != nil {
				t.Fatal(err)
			}

			f.Seek(0, 0)
			res, err := ioutil.ReadAll(f)
			if err != nil {
				t.Fatal(errors.Wrap(err, "could not read the tmp file"))
			}

			if diff := cmp.Diff(strings.Split(string(res), "\n"), strings.Split(test.after, "\n")); diff != "" {
				t.Errorf("the result file has diff: %s", diff)
			}
		})
	}
}
